function datastruct = getData(filename, ~)
% Reads Philips SPAR/SDAT files 
% By Iain Ball, v1.0, 20/01/2012
% Modified by Tom Sitter, v1.1, 09/06/2012
%   Created struct for integration with other scripts
%
% Syntax: [spec_data,parms,dims,fname] = GetData_sparsdat(filename,info);
%
% Inputs:
%           If no inputs, via UI, select name of SPAR file
%           ASSUMES the SDAT file in the SAME FOLDER as the SPAR file
%           With inputs:
%                       filename = filename (with path) of SPAR file
%                       info = if exists, prints information to command window
%
% Outputs: spec_data: data matrix containing time domain (FID)/frequency domain (spectrum)
%          parms: structure containing SPAR file info
%          dims: [rows samples]
%
% Data format of .SDAT files is VAXD complex floats.
% Calls to fopen with any of the following values for machine format return an error:
%
%'vaxd' or 'd'
%'vaxg' or 'g'
%'cray' or 'c'
%
% To read files in VAXD and VAXG formats, consider the workaround available on the MATLAB Central File Exchange, file ID #22675.
% http://www.mathworks.com/matlabcentral/fileexchange/22675
% This function will only run once these files have been installed into your MATLAB directory. 
%=============================================================================================================================================

%% *CHECK INPUT*
if nargin < 1
    try
        [fname,pname] = uigetfile({'*.SPAR;*.mat'},'Select *.SPAR, or *.mat file');

        if isequal(fname,0) || isequal(pname,0)
           disp('User pressed cancel')
        else
           disp(['User selected ', fullfile(pname, fname)])
        end
        
        filename=[pname fname];
    catch err
        disp(err.message)
    end
end

tic;

%Tom 09/06/2012
%changed output to data struture for use with HPG_DataAnalyzer
%include dims as parameter in parms
if (fname)
    format = fname(end-3:end);
    if strcmp(format, '.mat')
        file = [pname fname];
        %this should contain a structure with the fields of a hyppo
        %object
        datastruct = load(file);
    else %strcmp(format, 'SPAR')
        [parms,SPAR_type] = read_sparfile(filename);
        [spec_data,dims] = read_sdatfile([filename(1:(end-5)) '.SDAT'],parms);
        parms.dims = dims;
        datastruct = struct('spec_data', spec_data, ...
                            'parms', parms, ... 
                            'filename',fname, ...
                            'ver', SPAR_type, ...
                            'raw', 1); %differentiate from complete object
%     else %assume PAR file
%         [parms,ver] = read_parfile(filename);
%         [MR_data,dims] = read_recfile([filename(1:end-4) '.REC'],parms,ver,'SV');
%         parms.dims = dims;
%         parms.rows = parms.max_slices * parms.max_dynamics;
%         parms.samples = parms.stride;
%         datastruct = struct('spec_data', MR_data, ...
%                             'parms', parms, ... 
%                             'filename',fname, ...
%                             'ver', ver, ...
%                             'raw', 1); %differentiate from complete object
    end
end

if nargin > 1
    
    fprintf('%s\n',SPAR_type)                                
    fprintf('Read %d dataset(s) of size [%d x %d]\n',dims(1),dims(1:2));
    fprintf('nucleus: %s, # averages: %d, TR: %5.4f ms, spectral bandwidth: %d Hz\n',parms.nucleus,parms.NSA,parms.TR,parms.sample_frequency);
    disp(['Total execution time = ' num2str(toc)]);
    
end


return;

%=============================================================================================================================================

function [parms,SPAR_type] = read_sparfile(filename)

%% *READ ALL LINES OF THE SPAR FILE*
nlines  = 0;                                                                     % initialise number of lines
fid = fopen(filename,'r');                                                       % read file

if (fid < 1)
    error(['.SPAR file ', filename, ' not found.']);
end

while ~feof(fid)                                                                 % feof tests for end of file - whilst not EOF.
    curline = fgetl(fid);                                                        % current line - fget1 removes newline \n character 
%     curline = fgets(fid);                                                      % fgets keeps newline characters resulting in more lines  
    if ~isempty(curline)                                                         % if current line not empty then... 
        nlines = nlines + 1;                                                     % increase loop counter
        lines(nlines) = cellstr(curline);                                        % allows variable line size - doesn't matter if fgetl or fgets
    end
end
fclose(fid);

SPAR_type = lines{11};
SPAR_type = SPAR_type(3:end);                                                    % line 11 of SPAR file is a sentence indicating whether data is
SPAR_type = strjust(SPAR_type,  'left');                                         % in time domain or frequency domain

%% *IDENTIFY ONLY LINES OF DATA*
NG = 0;

for L = 1:size(lines,2)
    curline = char(lines(L));
    if (size(curline,2) > 0 && curline(1) ~= '!')                                % character strings of length greater than 0 and with ! at 
       NG = NG + 1;                                                              % start are identified and discarded
       geninfo(NG) = lines(L);                                                   % geninfo - i.e ALL INFORMATION of SPAR file. 
    end
end

if (NG < 1)
    error('.SPAR file has invalid format');
end

%% *SPAR FILE TEMPLATE*                                                                  
% far from complete! still need to see what options open up when;
% phase encoding enable set to "yes"
% t1 measurement enable set to "yes"
% t2 measurement enable set to "yes"
% time series enable set to "yes"
template = { ...
    'examination_name :'            'char  ' 'examination_name'; ...  
    'scan_id :'                     'char  ' 'scan_id'; ...
    'scan_date :'                   'char  ' 'scan_date'; ...
    'patient_name :'                'char  ' 'patient_name'; ... 
    'patient_birth_date :'          'char  ' 'patient_birth_date'; ...
    'patient_position :'            'char  ' 'patient_position'; ...
    'patient_orientation :'         'char  ' 'patient_orientation'; ...
    'samples :'                     'float ' 'samples'; ...
    'rows :'                        'float ' 'rows'; ...
    'synthesizer_frequency :'       'float ' 'synthesizer_frequency'; ...
    'offset_frequency :'            'float ' 'offset_frequency'; ...
    'sample_frequency :'            'float ' 'sample_frequency'; ...
    'echo_nr :'                     'float ' 'echo_nr'; ...
    'mix_number :'                  'float ' 'mix_number'; ...
    'nucleus :'                     'char  ' 'nucleus'; ...
    't0_mu1_direction :'            'float ' 't0_mu1_direction'; ...
    'echo_time :'                   'float ' 'TE'; ...
    'repetition_time :'             'float ' 'TR'; ...
    'averages :'                    'float ' 'NSA'; ...
    'volume_selection_enable :'     'char  ' 'volume_selection_enable'; ...
    'volumes :'                     'float ' 'volumes'; ...
    'ap_size :'                     'float ' 'ap_size'; ...
    'lr_size :'                     'float ' 'lr_size'; ...
    'cc_size :'                     'float ' 'cc_size'; ...
    'ap_off_center :'               'float ' 'ap_off_center'; ...
    'lr_off_center :'               'float ' 'lr_off_center'; ...
    'cc_off_center :'               'float ' 'cc_off_center'; ... 
    'ap_angulation :'               'float ' 'ap_angulation'; ...
    'lr_angulation :'               'float ' 'lr_angulation'; ...
    'cc_angulation :'               'float ' 'cc_angulation'; ...
    'volume_selection_method :'     'float ' 'volume_selection_method'; ...
    'phase_encoding_enable :'       'char  ' 'phase_encoding_enable'; ...
    't1_measurement_enable :'       'char  ' 't1_measurement_enable'; ...
    't2_measurement_enable :'       'char  ' 't2_measurement_enable'; ...
    'time_series_enable :'          'char  ' 'time_series_enable'; ...
    'image_plane_slice_thickness :' 'float ' 'image_plane_slice_thickness'; ...
    'slice_distance :'              'float ' 'slice_distance'; ...
    'nr_of_slices_for_multislice :' 'float ' 'nr_of_slices_for_multislice'; ...
    'Spec.image in plane transf :'  'char  ' 'Spec_image_in_plane_transf'; ...
    'spec_data_type :'              'char  ' 'spec_data_type'; ...
    'spec_sample_extension :'       'char  ' 'spec_sample_extension'; ...
    'spec_num_col :'                'float ' 'spec_num_col'; ...
    'spec_col_lower_val :'          'float ' 'spec_col_lower_val'; ...
    'spec_col_upper_val :'          'float ' 'spec_col_upper_val'; ...
    'spec_col_extension :'          'char  ' 'spec_col_extension'; ...
    'spec_num_row :'                'float ' 'spec_num_row'; ...
    'spec_row_lower_val :'          'float ' 'spec_row_lower_val'; ...
    'spec_row_upper_val :'          'float ' 'spec_row_upper_val'; ...
    'spec_row_extension :'          'char  ' 'spec_row_extension'; ...
    'num_dimensions :'              'float ' 'num_dimensions'; ...
    'dim1_ext       :'              'char  ' 'dim1_ext'; ...
    'dim1_pnts :'                   'float ' 'dim1_pnts'; ...
    'dim1_low_val :'                'float ' 'dim1_low_val'; ...
    'dim1_step :'                   'float ' 'dim1_step'; ...
    'dim1_direction :'              'char  ' 'dim1_direction'; ...
    'dim1_t0_point :'               'float ' 'dim1_t0_point'; ...
    'dim2_ext :'                    'char  ' 'dim2_ext'; ...
    'dim2_pnts :'                   'float ' 'dim2_pnts'; ...
    'dim2_low_val :'                'float ' 'dim2_low_val'; ...
    'dim2_step :'                   'float ' 'dim2_step'; ...
    'dim2_direction :'              'char  ' 'dim2_direction'; ...
    'dim2_t0_point :'               'float ' 'dim2_t0_point'; ...
    'dim3_ext :'                    'char  ' 'dim3_ext'; ...
    'dim3_pnts :'                   'float ' 'dim3_pnts'; ...
    'dim3_low_val :'                'float ' 'dim3_low_val'; ...
    'dim3_step :'                   'float ' 'dim3_step'; ...
    'dim3_direction :'              'char  ' 'dim3_direction'; ...
    'dim3_t0_point :'               'float ' 'dim3_t0_point'; ...
    'echo_acquisition :'            'char  ' 'echo_acquisition'; ...
    'TSI_factor :'                  'float ' 'TSI_factor'; ...
    'spectrum_echo_time :'          'float ' 'spectrum_echo_time'; ...
    'spectrum_inversion_time :'     'float ' 'spectrum_inversion_time'; ...
    'image_chemical_shift :'        'float ' 'image_chemical_shift'; ...
    'resp_motion_comp_technique :'  'char  ' 'resp_motion_comp_technique'; ...
    'de_coupling :'                 'char  ' 'de_coupling'; ...
    'equipment_sw_verions :'        'char  ' 'equipment_sw_verions'; ...
    'placeholder1 :'                'char  ' 'placeholder1'; ...
    'placeholder2 :'                'char  ' 'placeholder2'; ...
    };
%% *PARSE IDENTIFIED PARAMETER INFORMATION*
for S = 1:size(template,1)
    line_key = char(template(S,1));                                      % e.g. examination_name                                       
    value_type = char(template(S,2));                                    % e.g. float                                     
    field_name = char(template(S,3));                                    % e.g. examination_name --> line key = field name for most parameters
    L = strncmp(line_key,geninfo,size(line_key,2));                      % strncmp returns index of line_key within geninfo cell structure
%     L = strmatch(line_key,geninfo);                                         

    if ~isempty(L)
        curline = char(geninfo(L));
        value_start = 1 + strfind(curline,':');                          % find index of : within curline and start 1 after it                              
        value_end = size(curline,2);
    else
        value_type = ':-( VALUE NOT FOUND )-:';                          % allows code to still run even if nothing is found...this is a                             
    end                                                                  % redundancy should a specific field name return a void   

    switch (value_type)                                                  % parse header with field_names taking value_type into account                                                          
    case {'float '}                                                                
         parms.(field_name) = str2num(curline(value_start:value_end));   % floats are number fields or parameters that require precision to the decimal place.
    case {'char  '}
         parms.(field_name) = strtrim(curline(value_start:value_end));   % justify string and trim any whitespace/null characters         
    otherwise 
         parms.(field_name) = '';                                        % if field name identified but empty then fill with ''
    end

end

return

function [spec_data,dims] = read_sdatfile(sdatfile_name,parms)

%% *READ IN .SDAT FILE*
fid = fopen(sdatfile_name,'r','l');                               % VAX-D format - need to fix little endian ordering

if fid < 0
    fprintf('Could not open file %s\n',sdatfile_name)
end

% [binary_1D,read_size] = fread(fid,inf,'float32');               % won't work!

binary_1D = freadVAXD(fid, inf, 'float32');                       % freadVAXD/freadVAXG only accepts 3 inputs and spits out one output 
fclose(fid);

read_size = length(binary_1D);

if (read_size ~= parms.samples*parms.rows*2)
    fprintf('Expected %d int. Found %d int\n',parms.samples*parms.rows*2,read_size);       % error catching  
    if (read_size > parms.samples*parms.rows*2)
        error('.SDAT file has more data than expected from .SPAR file parameters')
    else
        error('.SDAT file has less data than expected from .SPAR file parameters')
    end
else
    fprintf('%s\n','.SDAT file read sucessfully');
end

binary_1D = binary_1D.';
im = binary_1D(1:2:length(binary_1D)) + 1i*binary_1D(2:2:length(binary_1D));  % differentiate real and imaginary numbers from binary data
spec_data = reshape(im,length(im)/parms.rows,parms.rows).';                   % reshape into respective datasets

rows = parms.rows;
samples = parms.samples;
dims = [rows samples];

return

%=============================================================================================================================================

function [parms,ver] = read_parfile(filename)

%% *READ ALL LINES OF THE PAR FILE*
nlines  = 0;                                                               % initialise number of lines
fid = fopen(filename,'r');                                                 % read file

if (fid < 1)
    error(['.PAR file ', filename, ' not found.']);
end

while ~feof(fid)                                                           % feof tests for end of file - whilst not EOF.
    curline = fgetl(fid);                                                  % current line - fget1 removes newline \n character 
%     curline = fgets(fid);                                                % fgets keeps newline characters resulting in more lines  
    if ~isempty(curline)                                                   % if current line not empty then... 
        nlines = nlines + 1;                                               % increase loop counter
        lines(nlines) = cellstr(curline);                                  % allows variable line size - doesn't matter if fgetl or fgets
    end
end
fclose(fid);

%% *IDENTIFY HEADER FILE LINES*
NG = 0;

for L = 1:size(lines,2)
    curline = char(lines(L));
    if (size(curline,2) > 0 && curline(1) == '.')                          % character strings of length greater than 0 and with . at 
       NG = NG + 1;                                                        % start are identified as a header line and stored in cell array
       geninfo(NG) = lines(L);                                             % geninfo - i.e GENERAL INFORMATION section of PAR file. 
    end
end

if (NG < 1)
    error('.PAR file has invalid format');
end

%% *FIGURE OUT IF v3 OR v4 PAR FILES*
test_key = '.    Image pixel size [8 or 16 bits]    :';                    % only V3 has that key in the headers

if strcmp(test_key,geninfo);
    ver = 'V3';
    template = get_template_v3;
else
    ver = 'V4.2';
    template = get_template_v42;                                           % even if .PAR file is v4.1 code will still work but will have
end;                                                                       % empty fields in parms structure

%% *PARSE HEADER INFORMATION*
for S = 1:size(template,1)
    line_key = char(template(S,1));                                        % e.g. EPI Factor
    value_type = char(template(S,2));                                      % e.g. int  scalar
    field_name = char(template(S,3));                                      % e.g. epi_factor
    L = strncmp(line_key,geninfo,size(line_key,2));                        % strncmp returns index of line_key within geninfo
%     L = strmatch(line_key,geninfo);  
    
    if ~isempty(L)
        curline = char(geninfo(L));
        value_start = 1 + strfind(curline,':');                            % find index of : within curline and start 1 after it 
        value_end = size(curline,2);
    else
        value_type = ':-( VALUE NOT FOUND )-:';                            % allows code to still run even if nothing is found...this is a 
    end                                                                    % redundancy should v4.1 .PAR files be loaded

    switch (value_type)                                                    % parse header with field_names taking value_type into account
    case { 'float scalar' 'int   scalar' 'float vector' 'int   vector'}    % floats are multiple number fields or parameters that need the decimal place.
         parms.(field_name) = str2num(curline(value_start:value_end));
    case { 'char  scalar' 'char  vector' }
         parms.(field_name) = strtrim(curline(value_start:value_end));     % justify string and trim any whitespace/null characters
    otherwise
         parms.(field_name) = '';
    end

end

%% *PARSE THE TAGS FOR EACH LINE OF DATA*
nimg  = 0;

for L = 1:size(lines,2)
    curline = char(lines(L));                                                     % read lines in one at a time
    firstc = curline(1);                                                          % identify 1st character of each line                                                   
    if (size(curline,2) > 0 && firstc ~= '.' && firstc ~= '#' && firstc ~= '*')   % conditions for tag parsing
       nimg = nimg + 1;
       parms.tags(nimg,:) = str2num(curline);                                     % parms.tags is nimgx49 row of data
    end
end

if (isfield(parms,'recon_resolution'))                                     % if upsampled then need to know this parameter in order to read .REC file correctly
    nline = parms.recon_resolution(1);                                     % the field recon_resolution is unique to v3 PAR files.
    stride = parms.recon_resolution(2);
else
    nline = parms.tags(1,10);                                              % nline and stride are essentially the number of samples and views unless upsampled
    stride = parms.tags(1,11);                                             % these values are used to specify the interimage spacing within the .REC file 
end

slice_orientation = parms.tags(1,26);                                      % TRANSVERSE = 1, SAGITTAL = 2, CORONAL = 3
                                                                           % assumes same for all images - localiser scans won't work!
switch (slice_orientation)
    case { 1 }, parms.slice_orientation = 'TRANSVERSE';
    case { 2 }, parms.slice_orientation = 'SAGITTAL';
    case { 3 }, parms.slice_orientation = 'CORONAL';
    otherwise
        error('Unknown oblique orientation')
end

% if parms.max_slices == parms.fov(1)/parms.slice_thickness
%     parms.slice_orientation = 'CORONAL';
% elseif parms.max_slices == parms.fov(2)/parms.slice_thickness            % less efficient way!                    !
%     parms.slice_orientation = 'TRANSVERSE';
% else
%     parms.slice_orientation = 'SAGITTAL';
% end

parms.reconstruction_res = [nline stride];                                         % reconstruction resolution
parms.image_types = unique(parms.tags(:,5)');                                      % image types
parms.slice_thickness = unique(parms.tags(:,23));                                  % (mm)
parms.slice_gap = unique(parms.tags(:,24));                                        % (mm)
parms.b_factor = unique(parms.tags(:,34));                                         % b-factors
parms.b_factor_number = unique(parms.tags(:,42));                                  % number of diffusion b-factors/weightings                             
parms.echo_time = unique(parms.tags(:,31));                                        % TE (ms)
parms.num_averages = unique(parms.tags(:,35));                                     % number of signal averages            
parms.flip_angle = unique(parms.tags(:,36));                                       % flip angle
parms.turbo_factor = unique(parms.tags(:,40));                                     % turbo factor 
parms.receiver_bandwidth = 0.22*parms.scan_resolution(1)/parms.water_fat_shift;    % +/- bandwidth in kHz - 0.22 scaling for 3T - 0.11 for 1.5T

if (nimg < 1)
    error('Missing scan information in .PAR file') 
end

return

%=============================================================================================================================================

function [image_data,dims] = read_recfile(recfile_name,parms,ver,output_format)

%% *MATCH TAGS TO IMAGE INFORMATION*
types_list = unique(parms.tags(:,5)');              % handles multiple image types - 0,1,2,3 - mag, real, imag, phase - unique avoids repetitions
scan_tag_size = size(parms.tags);
nimg = scan_tag_size(1);                            % number of images does not always equal number slices - may have numerous image types per slice
nslice = parms.max_slices;                          % number of slices 
nphase = parms.max_card_phases;                     % number of cardiac phases
necho = parms.max_echoes;                           % number of echoes
ndyn = parms.max_dynamics;                          % number of dynamics
ntype = size(types_list,2);                         % number of image types

if (isfield(parms,'recon_resolution'))              
    nline = parms.recon_resolution(1);                                     % same code as previously written needed for execution of nested read_recfile function        
    stride = parms.recon_resolution(2);                                    % nline*stride used for error catching and interimage spacing specifications
else
    nline = parms.tags(1,10);                       
    stride = parms.tags(1,11);                       
end

switch(ver)
    case {'V3'}, pixel_bits = parms.pixel_bits;
    case {'V4.2'}, pixel_bits = parms.tags(1,8);                           % assume same for all images - 16 bit unsigned integers
end

switch (pixel_bits)
    case { 8 },  read_type = 'uint8';
    case { 16 }, read_type = 'short';                                      % default for short is 16 or could just write uint16                    
    otherwise,   read_type = 'uchar';
end

%% *READ .REC FILE*
fid = fopen(recfile_name,'r','l');                                                 % read bits in file with little endian ordering
[binary_1D,read_size] = fread(fid,inf,read_type);                                  % read everything (inf) as read_type
fclose(fid);

if (read_size ~= nimg*nline*stride)
    fprintf('Expected %d int.  Found %d int\n',nimg*nline*stride,read_size);       % error catching - this section of code is now redundant  
    if (read_size > nimg*nline*stride)
        error('.REC file has more data than expected from .PAR file')
    else
        error('.REC file has less data than expected from .PAR file')
    end
else
    fprintf('%s\n','.REC file read sucessfully');
end

%% *GENERATE MATRIX OF IMAGES*
dims = [stride nline nslice necho nphase ntype ndyn];                         % dimensions of image
image_data = zeros(dims);

for I  = 1:nimg
    slice = parms.tags(I,1);
    echo = parms.tags(I,2);
    dyn = parms.tags(I,3);
    phase = parms.tags(I,4);
    type = parms.tags(I,5);                                                   % 0,1,2,3
    type_idx = types_list == type;                                            % images to be displayed slice 1, type 0, slice 1 type 1 etc
    seq = parms.tags(I,6);                                                    % scanning sequence number
    rec = parms.tags(I,7);                                                    % index in .REC file          

    start_image = 1+rec*nline*stride;                                         % need the 1 because rec index starts at zero!
    end_image = start_image + stride*nline - 1;                               % now need to subtract the 1!
    img = reshape(binary_1D(start_image:end_image),stride,nline);             % reshape 1D matrix into 2D matrix 

    %% *RESCALE DATA TO PRODUCE SV INFORMATION (not FP, not DV)*
    img = permute(rescale_rec(img,parms.tags(I,:),ver,output_format), [2 1]); % permute matrix otherwise image rotated 90 degs
    image_data(:,:,slice,echo,phase,type_idx,dyn) = img;
end
return;
    
%=============================================================================================================================================

function img = rescale_rec(img,tag,ver,output_format)

%% *TRANSFORMS SV DATA IN REC FILES TO SV, DV OR FP DATA FOR OUTPUT*
switch( ver )
    case { 'V3' }, ri_i = 8; rs_i = 9; ss_i = 10;
    case { 'V4.2' }, ri_i = 12; rs_i = 13; ss_i = 14;   % recon resolution is one field but occupies two cells resulting in index being 12 instead of 11
end;
 
RI = tag(ri_i);                                                  % Rescale Intercept
RS = tag(rs_i);                                                  % Rescale Slope
SS = tag(ss_i);                                                  % Scale Slope

switch (output_format)
    case { 'FP' }, img = (RS*img + RI)./(RS*SS);
    case { 'DV' }, img = (RS*img + RI);
    case { 'SV' }, img = img;
end

return;

%=============================================================================================================================================
%% *PAR FILE VERSION TEMPLATES*

function [template] = get_template_v3                                    % header information for V3 PAR files

template = { ...                                  
'.    Patient name                       :'    'char  scalar'    'patient';    ...   
'.    Examination name                   :'    'char  scalar'    'exam_name';   ... 
'.    Protocol name                      :'    'char  vector'    'protocol';   ... 
'.    Examination date/time              :'    'char  vector'    'exam_date';  ...
'.    Acquisition nr                     :'    'int   scalar'    'acq_nr';    ...
'.    Reconstruction nr                  :'    'int   scalar'    'recon_nr';  ...
'.    Scan Duration [sec]                :'    'float scalar'    'scan_dur';        ...
'.    Max. number of cardiac phases      :'    'int   scalar'    'max_card_phases'; ...
'.    Max. number of echoes              :'    'int   scalar'    'max_echoes'; ...
'.    Max. number of slices/locations    :'    'int   scalar'    'max_slices'; ... 
'.    Max. number of dynamics            :'    'int   scalar'    'max_dynamics'; ... 
'.    Max. number of mixes               :'    'int   scalar'    'max_mixes'; ... 
'.    Image pixel size [8 or 16 bits]    :'    'int   scalar'    'pixel_bits'; ... 
'.    Technique                          :'    'char  scalar'    'technique'; ...  
'.    Scan mode                          :'    'char  scalar'    'scan_mode'; ... 
'.    Scan resolution  (x, y)            :'    'int   vector'    'scan_resolution'; ... 
'.    Scan percentage                    :'    'int   scalar'    'scan_percentage'; ... 
'.    Recon resolution (x, y)            :'    'int   vector'    'recon_resolution'; ... 
'.    Number of averages                 :'    'int   scalar'    'num_averages'; ... 
'.    Repetition time [msec]             :'    'float scalar'    'repetition_time'; ...   
'.    FOV (ap,fh,rl) [mm]                :'    'float vector'    'fov'; ... 
'.    Slice thickness [mm]               :'    'float scalar'    'slice_thickness'; ...
'.    Slice gap [mm]                     :'    'float scalar'    'slice_gap'; ... 
'.    Water Fat shift [pixels]           :'    'float scalar'    'water_fat_shift'; ... 
'.    Angulation midslice(ap,fh,rl)[degr]:'    'float vector'    'angulation'; ...
'.    Off Centre midslice(ap,fh,rl) [mm] :'    'float vector'    'offcenter'; ... 
'.    Flow compensation <0=no 1=yes> ?   :'    'int   scalar'    'flowcomp'; ...
'.    Presaturation     <0=no 1=yes> ?   :'    'int   scalar'    'presaturation';... 
'.    Cardiac frequency                  :'    'int   scalar'    'card_frequency'; ...
'.    Min. RR interval                   :'    'int   scalar'    'min_rr_interval'; ...
'.    Max. RR interval                   :'    'int   scalar'    'max_rr_interval'; ...
'.    Phase encoding velocity [cm/sec]   :'    'float vector'    'venc'; ... 
'.    MTC               <0=no 1=yes> ?   :'    'int   scalar'    'mtc'; ...
'.    SPIR              <0=no 1=yes> ?   :'    'int   scalar'    'spir'; ...
'.    EPI factor        <0,1=no EPI>     :'    'int   scalar'    'epi_factor'; ...
'.    TURBO factor      <0=no turbo>     :'    'int   scalar'    'turbo_factor'; ...
'.    Dynamic scan      <0=no 1=yes> ?   :'    'int   scalar'    'dynamic_scan'; ...
'.    Diffusion         <0=no 1=yes> ?   :'    'int   scalar'    'diffusion'; ...
'.    Diffusion echo time [ms]           :'    'float scalar'    'diffusion_echo_time'; ...
'.    Inversion delay [ms]               :'    'float scalar'    'inversion_delay'; ...
};

return;

%=============================================================================================================================================

function [template] = get_template_v41                                         % header information for V4 PAR files

template = { ...                                  
'.    Patient name                       :' 'char  scalar' 'patient';    ...   
'.    Examination name                   :' 'char  vector' 'exam_name';   ... 
'.    Protocol name                      :' 'char  vector' 'protocol';   ... 
'.    Examination date/time              :' 'char  vector' 'exam_date';  ...
'.    Series Type                        :' 'char  vector' 'series_type';  ...
'.    Acquisition nr                     :' 'int   scalar' 'acq_nr';    ...
'.    Reconstruction nr                  :' 'int   scalar' 'recon_nr';  ...
'.    Scan Duration [sec]                :' 'float scalar' 'scan_dur';        ...
'.    Max. number of cardiac phases      :' 'int   scalar' 'max_card_phases'; ...
'.    Max. number of echoes              :' 'int   scalar' 'max_echoes'; ...
'.    Max. number of slices/locations    :' 'int   scalar' 'max_slices'; ... 
'.    Max. number of dynamics            :' 'int   scalar' 'max_dynamics'; ... 
'.    Max. number of mixes               :' 'int   scalar' 'max_mixes'; ... 
'.    Patient position                   :' 'char  vector' 'patient_position'; ... 
'.    Preparation direction              :' 'char  vector' 'preparation_dir'; ... 
'.    Technique                          :' 'char  scalar' 'technique'; ...  
'.    Scan resolution  (x, y)            :' 'int   vector' 'scan_resolution'; ... 
'.    Scan mode                          :' 'char  scalar' 'scan_mode'; ... 
'.    Repetition time [ms]               :' 'float scalar' 'repetition_time'; ...   
'.    FOV (ap,fh,rl) [mm]                :' 'float vector' 'fov'; ... 
'.    Water Fat shift [pixels]           :' 'float scalar' 'water_fat_shift'; ... 
'.    Angulation midslice(ap,fh,rl)[degr]:' 'float vector' 'angulation'; ...
'.    Off Centre midslice(ap,fh,rl) [mm] :' 'float vector' 'offcenter'; ... 
'.    Flow compensation <0=no 1=yes> ?   :' 'int   scalar' 'flowcomp'; ...
'.    Presaturation     <0=no 1=yes> ?   :' 'int   scalar' 'presaturation';... 
'.    Phase encoding velocity [cm/sec]   :' 'float vector' 'venc'; ... 
'.    MTC               <0=no 1=yes> ?   :' 'int   scalar' 'mtc'; ...
'.    SPIR              <0=no 1=yes> ?   :' 'int   scalar' 'spir'; ...
'.    EPI factor        <0,1=no EPI>     :' 'int   scalar' 'epi_factor'; ...
'.    Dynamic scan      <0=no 1=yes> ?   :' 'int   scalar' 'dynamic_scan'; ...
'.    Diffusion         <0=no 1=yes> ?   :' 'int   scalar' 'diffusion'; ...
'.    Diffusion echo time [ms]           :' 'float scalar' 'diffusion_echo_time'; ...
};

return;

%=============================================================================================================================================

function [template] = get_template_v42                                            % header information for V4.2 PAR files

template = { ...                                  
'.    Patient name                       :' 'char  scalar' 'patient';    ...   
'.    Examination name                   :' 'char  vector' 'exam_name';   ... 
'.    Protocol name                      :' 'char  vector' 'protocol';   ... 
'.    Examination date/time              :' 'char  vector' 'exam_date';  ...
'.    Series Type                        :' 'char  vector' 'series_type';  ...
'.    Acquisition nr                     :' 'int   scalar' 'acq_nr';    ...
'.    Reconstruction nr                  :' 'int   scalar' 'recon_nr';  ...
'.    Scan Duration [sec]                :' 'float scalar' 'scan_dur';        ...
'.    Max. number of cardiac phases      :' 'int   scalar' 'max_card_phases'; ...
'.    Max. number of echoes              :' 'int   scalar' 'max_echoes'; ...
'.    Max. number of slices/locations    :' 'int   scalar' 'max_slices'; ... 
'.    Max. number of dynamics            :' 'int   scalar' 'max_dynamics'; ... 
'.    Max. number of mixes               :' 'int   scalar' 'max_mixes'; ... 
'.    Patient position                   :' 'char  vector' 'patient_position'; ... 
'.    Preparation direction              :' 'char  vector' 'preparation_dir'; ... 
'.    Technique                          :' 'char  scalar' 'technique'; ...  
'.    Scan resolution  (x, y)            :' 'int   vector' 'scan_resolution'; ... 
'.    Scan mode                          :' 'char  scalar' 'scan_mode'; ... 
'.    Repetition time [ms]               :' 'float scalar' 'repetition_time'; ...   
'.    FOV (ap,fh,rl) [mm]                :' 'float vector' 'fov'; ... 
'.    Water Fat shift [pixels]           :' 'float scalar' 'water_fat_shift'; ... 
'.    Angulation midslice(ap,fh,rl)[degr]:' 'float vector' 'angulation'; ...
'.    Off Centre midslice(ap,fh,rl) [mm] :' 'float vector' 'offcenter'; ... 
'.    Flow compensation <0=no 1=yes> ?   :' 'int   scalar' 'flowcomp'; ...
'.    Presaturation     <0=no 1=yes> ?   :' 'int   scalar' 'presaturation';... 
'.    Phase encoding velocity [cm/sec]   :' 'float vector' 'venc'; ... 
'.    MTC               <0=no 1=yes> ?   :' 'int   scalar' 'mtc'; ...
'.    SPIR              <0=no 1=yes> ?   :' 'int   scalar' 'spir'; ...
'.    EPI factor        <0,1=no EPI>     :' 'int   scalar' 'epi_factor'; ...
'.    Dynamic scan      <0=no 1=yes> ?   :' 'int   scalar' 'dynamic_scan'; ...
'.    Diffusion         <0=no 1=yes> ?   :' 'int   scalar' 'diffusion'; ...
'.    Diffusion echo time [ms]           :' 'float scalar' 'diffusion_echo_time'; ...
'.    Max. number of diffusion values    :' 'int   scalar' 'num_diffusion'; ...
'.    Max. number of gradient orients    :' 'int   scalar' 'num_orients'; ...
'.    Number of label types   <0=no ASL> :' 'int   vector' 'num_label_types';...
};

return;
%=============================================================================================================================================
